package com.siemens.einkaufsliste;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.List;
import java.util.Optional;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

import com.siemens.einkaufsliste.database.model.Product;
import com.siemens.einkaufsliste.database.model.Product.Category;
import com.siemens.einkaufsliste.database.repository.Database;
import com.siemens.einkaufsliste.database.repository.ProductRepository;

@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public final class ProductDatabaseRepositoryTest {

	private static ProductRepository productRepository;
	private static Product testProduct;

	@BeforeAll
	static void setupDatabase() throws Exception {
		Database.connect();
		productRepository = Database.getProducts();
	}

	@AfterAll
	static void teardownDatabase() {
		Database.disconnect();
	}

	@Test
	@Order(1)
	@DisplayName("Should successfully add a test product")
	void addTestProduct() throws Exception {
		Product inputProduct = new Product(0, "Test Apple", Category.FRUITS, "BioBrand", 299);

		testProduct = productRepository.addProduct(inputProduct);

		assertNotNull(testProduct, "Returned product must not be null");
		assertNotEquals(0, testProduct.productID(), "ID must be generated by database");
		assertEquals("Test Apple", testProduct.name());
	}

	@Test
	@Order(2)
	@DisplayName("Should retrieve all products containing test product")
	void getAllProducts() throws Exception {
		List<Product> products = productRepository.getProducts();

		assertNotNull(products);
		assertFalse(products.isEmpty(), "Product list should not be empty");

		boolean found = products.stream().anyMatch(p -> p.productID() == testProduct.productID());

		assertTrue(found, "The added product (ID " + testProduct.productID() + ") was not found");
	}

	@Test
	@Order(3)
	@DisplayName("Should retrieve product by ID successfully")
	void getProductById() throws Exception {
		Optional<Product> foundProduct = productRepository.getProduct(testProduct.productID());

		assertTrue(foundProduct.isPresent(), "Product with ID " + testProduct.productID() + " should be found");
		assertEquals(testProduct.name(), foundProduct.get().name());
		assertEquals(testProduct.price(), foundProduct.get().price());
	}

	@Test
	@Order(4)
	@DisplayName("Should return empty optional for invalid product ID")
	void getProductByIdNotFound() throws Exception {
		Optional<Product> foundProduct = productRepository.getProduct(999999);
		assertFalse(foundProduct.isPresent(), "Product should not be found");
	}

	@Test
	@Order(5)
	@DisplayName("Should add multiple products with different categories")
	void addMultipleProducts() throws Exception {
		Product p1 = new Product(0, "Test Wheat Bread", Category.WHEAT, "BakerMaster", 249);
		Product p2 = new Product(0, "Test Laptop", Category.ELECTRONICS, "TechBrand", 89999);
		Product p3 = new Product(0, "Test Milk", Category.MILK, "AlpineMilk", 129);
		Product p4 = new Product(0, "Test Cola", Category.DRINKS, "CocaCola", 199);

		Product saved1 = productRepository.addProduct(p1);
		Product saved2 = productRepository.addProduct(p2);
		Product saved3 = productRepository.addProduct(p3);
		Product saved4 = productRepository.addProduct(p4);

		assertNotNull(saved1);
		assertNotNull(saved2);
		assertNotNull(saved3);
		assertNotNull(saved4);

		List<Product> products = productRepository.getProducts();
		assertTrue(products.stream().anyMatch(p -> p.name().equals("Test Wheat Bread")));
		assertTrue(products.stream().anyMatch(p -> p.name().equals("Test Milk")));

		productRepository.removeProduct(saved1.productID());
		productRepository.removeProduct(saved2.productID());
		productRepository.removeProduct(saved3.productID());
		productRepository.removeProduct(saved4.productID());
	}

	@Test
	@Order(6)
	@DisplayName("Should correctly filter products by all categories")
	void testAllCategories() throws Exception {
		Product wheat = new Product(0, "Test Wheat", Category.WHEAT, "Brand1", 100);
		Product electronics = new Product(0, "Test Electronics", Category.ELECTRONICS, "Brand2", 200);

		Product s1 = productRepository.addProduct(wheat);
		Product s2 = productRepository.addProduct(electronics);

		List<Product> products = productRepository.getProducts();

		assertTrue(products.stream().anyMatch(p -> p.category() == Category.WHEAT));
		assertTrue(products.stream().anyMatch(p -> p.category() == Category.ELECTRONICS));

		if (s1 != null) {
			productRepository.removeProduct(s1.productID());
		}
		if (s2 != null) {
			productRepository.removeProduct(s2.productID());
		}
	}

	@Test
	@Order(7)
	@DisplayName("Should allow adding product with zero price")
	void addProductWithZeroPrice() throws Exception {
		Product freeProduct = new Product(0, "Test Free Item", Category.SNACKS, "FreeBrand", 0);

		Product saved = productRepository.addProduct(freeProduct);
		assertNotNull(saved);
		assertEquals(0, saved.price());

		productRepository.removeProduct(saved.productID());
	}

	@Test
	@Order(8)
	@DisplayName("Should allow adding product with very high price")
	void addProductWithHighPrice() throws Exception {
		Product expensiveProduct = new Product(0, "Test Luxury", Category.ELECTRONICS, "LuxuryBrand", 999999);

		Product saved = productRepository.addProduct(expensiveProduct);

		assertNotNull(saved, "Saved product must not be null");
		assertEquals(999999, saved.price());

		Optional<Product> found = productRepository.getProduct(saved.productID());
		assertTrue(found.isPresent());
		assertEquals(999999, found.get().price());

		productRepository.removeProduct(saved.productID());
	}

	@Test
	@Order(9)
	@DisplayName("Should successfully remove an existing product")
	void removeProduct() throws Exception {
		assertNotEquals(0, testProduct.productID(), "Test product should have valid ID");

		Optional<Product> beforeRemoval = productRepository.getProduct(testProduct.productID());
		assertTrue(beforeRemoval.isPresent(), "Product should exist before removal");

		productRepository.removeProduct(testProduct.productID());

		Optional<Product> afterRemoval = productRepository.getProduct(testProduct.productID());
		assertFalse(afterRemoval.isPresent(), "Removed product should not be found");
	}

	@Test
	@Order(10)
	@DisplayName("Removing non-existent product should not throw exception")
	void removeProductNotFound() {
		assertDoesNotThrow(() -> {
			productRepository.removeProduct(999999);
		});
	}

	@Test
	@Order(11)
	@DisplayName("Should allow adding product with empty brand")
	void addProductWithEmptyBrand() throws Exception {
		Product noBrandProduct = new Product(0, "Test No Brand", Category.VEGETABLES, "", 150);

		Product saved = productRepository.addProduct(noBrandProduct);
		assertNotNull(saved);
		assertEquals("", saved.brand());

		productRepository.removeProduct(saved.productID());
	}

	@Test
	@Order(12)
	@DisplayName("Should correctly find products by category")
	void findProductsByCategory() throws Exception {

		Category searchCategory = Category.FRUITS;
		Category noiseCategory = Category.ELECTRONICS;

		Product target1 = new Product(0, "Search-Apple", searchCategory, "BioFarm", 199);
		Product target2 = new Product(0, "Search-Banana", searchCategory, "Chiquita", 299);
		Product noise1 = new Product(0, "Noise-Laptop", noiseCategory, "Dell", 99999);

		Product savedTarget1 = productRepository.addProduct(target1);
		Product savedTarget2 = productRepository.addProduct(target2);
		Product savedNoise1 = productRepository.addProduct(noise1);

		assertNotNull(savedTarget1);
		assertNotNull(savedTarget2);
		assertNotNull(savedNoise1);

		List<Product> foundProducts = productRepository.findProducts(searchCategory);

		assertNotNull(foundProducts, "Result list must not be null");
		assertFalse(foundProducts.isEmpty(), "Products should be found");

		boolean allMatchCategory = foundProducts.stream().allMatch(p -> p.category() == searchCategory);
		assertTrue(allMatchCategory, "All found products must match category " + searchCategory);

		boolean containsTarget1 = foundProducts.stream().anyMatch(p -> p.productID() == savedTarget1.productID());
		boolean containsTarget2 = foundProducts.stream().anyMatch(p -> p.productID() == savedTarget2.productID());

		assertTrue(containsTarget1, "Search-Apple should be found");
		assertTrue(containsTarget2, "Search-Banana should be found");

		boolean containsNoise = foundProducts.stream().anyMatch(p -> p.productID() == savedNoise1.productID());

		assertFalse(containsNoise, "Noise-Laptop (Electronics) should NOT be found");

		productRepository.removeProduct(savedTarget1.productID());
		productRepository.removeProduct(savedTarget2.productID());
		productRepository.removeProduct(savedNoise1.productID());
	}

	@Test
	@Order(13)
	@DisplayName("Should search products fuzzily and by substring")
	void searchProducts() throws Exception {

		Product targetSoundex = new Product(0, "Jägermeister 0.8L", Category.DRINKS, "Mast-Jägermeister", 1299);
		Product targetSubstring = new Product(0, "Cloudy Apple Juice", Category.DRINKS, "BioBrand", 199);
		Product noise = new Product(0, "Gaming Laptop", Category.ELECTRONICS, "Alienware", 200000);

		Product savedSoundex = productRepository.addProduct(targetSoundex);
		Product savedSubstring = productRepository.addProduct(targetSubstring);
		Product savedNoise = productRepository.addProduct(noise);

		List<Product> resultFuzzy = productRepository.searchProducts("jägar");

		assertNotNull(resultFuzzy);
		assertTrue(resultFuzzy.stream().anyMatch(p -> p.productID() == savedSoundex.productID()),
				"Search for 'jägar' should find 'Jägermeister' (Phonetic similarity)");

		assertFalse(resultFuzzy.stream().anyMatch(p -> p.productID() == savedNoise.productID()),
				"Search for 'jägar' should NOT find 'Gaming Laptop'");

		List<Product> resultSubstring = productRepository.searchProducts("Juice");

		assertTrue(resultSubstring.stream().anyMatch(p -> p.productID() == savedSubstring.productID()),
				"Search for 'Juice' should find 'Apple Juice' (Substring)");

		List<Product> resultCaps = productRepository.searchProducts("JÄGAR");
		assertTrue(resultCaps.stream().anyMatch(p -> p.productID() == savedSoundex.productID()),
				"Case sensitivity should be ignored");

		productRepository.removeProduct(savedSoundex.productID());
		productRepository.removeProduct(savedSubstring.productID());
		productRepository.removeProduct(savedNoise.productID());
	}

	@Test
	@Order(14)
	@DisplayName("Should filter search results by brand and price")
	void testComplexSearchFilter() throws Exception {

		Product hit = new Product(0, "Gaming Mouse", Category.ELECTRONICS, "Logitech", 50);
		Product tooExpensive = new Product(0, "Expensive Keyboard", Category.ELECTRONICS, "Logitech", 150);
		Product wrongBrand = new Product(0, "Other Headset", Category.ELECTRONICS, "Razer", 50);

		Product savedHit = productRepository.addProduct(hit);
		Product savedExp = productRepository.addProduct(tooExpensive);
		Product savedWrong = productRepository.addProduct(wrongBrand);

		String[] searchBrands = { "Logitech" };
		int maxPrice = 100;

		List<Product> results = productRepository.searchProducts("", maxPrice, -1, null, searchBrands);

		assertNotNull(results);
		assertFalse(results.isEmpty(), "One product should be found");
		assertEquals(1, results.size(), "Exactly one product should remain");

		assertEquals(savedHit.productID(), results.get(0).productID());

		productRepository.removeProduct(savedHit.productID());
		productRepository.removeProduct(savedExp.productID());
		productRepository.removeProduct(savedWrong.productID());
	}

	@Test
	@Order(15)
	@DisplayName("Should retrieve unique brands")
	void testGetUniqueBrands() throws Exception {
		Product p1 = new Product(0, "Record Player", Category.ELECTRONICS, "Sony", 500);
		Product p2 = new Product(0, "Fridge", Category.ELECTRONICS, "Sony", 100);
		Product p3 = new Product(0, "Air Fryer", Category.HOUSEHOLD, "Miele", 900);

		Product saved1 = productRepository.addProduct(p1);
		Product saved2 = productRepository.addProduct(p2);
		Product saved3 = productRepository.addProduct(p3);

		List<String> brands = productRepository.brands();

		assertNotNull(brands, "List must not be null");
		assertFalse(brands.isEmpty(), "List should contain entries");

		assertTrue(brands.contains("Sony"));
		assertTrue(brands.contains("Miele"));

		long sonyCount = brands.stream().filter(b -> b.equals("Sony")).count();
		assertEquals(1, sonyCount, "Brand 'Sony' should appear only once despite multiple products.");

		productRepository.removeProduct(saved1.productID());
		productRepository.removeProduct(saved2.productID());
		productRepository.removeProduct(saved3.productID());
	}
}